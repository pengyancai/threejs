THREE.DRACOLoader = function(a) {
    this.manager = void 0 !== a ? a: THREE.DefaultLoadingManager;
    this.materials = null
};
THREE.DRACOLoader.prototype = {
    constructor: THREE.DRACOLoader,
    load: function(a, h, e, b) {
        var l = this,
            p = new THREE.XHRLoader(this.manager);
        p.setResponseType("arraybuffer");
        p.load(a,
            function(a) {
                h(l.decodeDracoFile(a))
            },
            e, b)
    },
    setPath: function(a) {
        this.path = a
    },
    decodeDracoFile: function(a) {
        var h = new Module.DecoderBuffer;
        h.Init(new Int8Array(a), a.byteLength);
        a = new Module.WebIDLWrapper;
        var e = a.GetEncodedGeometryType(h);
        if (e != Module.TRIANGULAR_MESH && e != Module.POINT_CLOUD) throw Error("Error: Unknown geometry type.");
        return this.convertDracoGeometryTo3JS(a, e, h)
    },
    convertDracoGeometryTo3JS: function(a, h, e) {
        var b;
        b = h == Module.TRIANGULAR_MESH ? a.DecodeMeshFromBuffer(e) : a.DecodePointCloudFromBuffer(e);
        Module.destroy(e);
        var l, p, f, g;
        e = h == Module.TRIANGULAR_MESH ? b.num_faces() : 0;
        l = b.num_points();
        p = 3 * l;
        f = b.num_attributes();
        g = "Number of points loaded: " + l.toString() + ".\n";
        g += "Number of attributes loaded: " + f.toString() + ".\n";
        f = a.GetAttributeId(b, Module.POSITION);
        if ( - 1 == f) throw Module.destroy(a),
            Module.destroy(b),
            Error("No position attribute found in the mesh.");
        var k = a.GetAttribute(b, f);
        f = new Module.DracoFloat32Array;
        a.GetAttributeFloatForAllPoints(b, k, f);
        var r = a.GetAttributeId(b, Module.COLOR),
            d; - 1 != r && (g += "\nLoaded color attribute.\n", k = a.GetAttribute(b, r), d = new Module.DracoFloat32Array, a.GetAttributeFloatForAllPoints(b, k, d));
        var k = a.GetAttributeId(b, Module.NORMAL),
            m; - 1 != k && (g = a.GetAttribute(b, k), m = new Module.DracoFloat32Array, a.GetAttributeFloatForAllPoints(b, g, m));
        g = a.GetAttributeId(b, Module.TEX_COORD);
        var q;
        if ( - 1 != g) {
            var n = a.GetAttribute(b, g);
            q = new Module.DracoFloat32Array;
            a.GetAttributeFloatForAllPoints(b, n, q)
        }
        for (var n = [], u = [], v = [], w = [], t = [], c = 0; c < p; c += 3) u.push(f.GetValue(c), f.GetValue(c + 1), f.GetValue(c + 2)),
            -1 != r ? t.push(d.GetValue(c), d.GetValue(c + 1), d.GetValue(c + 2)) : t.push(1, 1, 1),
            -1 != k && v.push(m.GetValue(c), m.GetValue(c + 1), m.GetValue(c + 2));
        for (c = 0; c < 2 * l; c += 2) - 1 != g && w.push(q.GetValue(c), q.GetValue(c + 1));
        Module.destroy(f); - 1 != r && Module.destroy(d); - 1 != k && Module.destroy(m); - 1 != g && Module.destroy(q);
        if (h == Module.TRIANGULAR_MESH) {
            d = new DracoInt32Array;
            for (c = 0; c < e; ++c) a.GetFaceFromMesh(b, c, d),
                n.push(d.GetValue(0), d.GetValue(1), d.GetValue(2));
            Module.destroy(d)
        }
        Module.destroy(a);
        Module.destroy(b);
        a = new THREE.BufferGeometry;
        h == Module.TRIANGULAR_MESH && (65535 < n.length ? a.setIndex(new THREE.BufferAttribute(new Uint32Array(n), 1)) : a.setIndex(new THREE.BufferAttribute(new Uint16Array(n), 1)));
        a.addAttribute("position", new THREE.BufferAttribute(new Float32Array(u), 3));
        a.addAttribute("color", new THREE.BufferAttribute(new Float32Array(t), 3)); - 1 != k && a.addAttribute("normal", new THREE.BufferAttribute(new Float32Array(v), 3)); - 1 != g && a.addAttribute("uv", new THREE.BufferAttribute(new Float32Array(w), 2));
        return a
    }
};